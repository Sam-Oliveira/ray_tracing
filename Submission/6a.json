{"camera":{"position":[0,0,2.712],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","showWorldCoordinates":false,"showWireframe":false},"passes":{"Model":{},"Quad":{"R2T":{"shaders":{"vertex":{"source":"//vertex coordinates in world space for the render quad\n//attribute vec3 vertex_worldSpace;\n\n\n//texture coordinate for this vertex and the render quad\nattribute vec2 textureCoordinate_input;\n\n//texture coordinate needs to be passed on to the R2T fragment shader\nvarying vec2 varyingTextureCoordinate;\n\n// MY CODE \nattribute vec4 vertex_worldSpace;\nuniform float canvasWidth;\nuniform float canvasHeight;\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\nvarying vec3 origin;\nvarying vec3 dir;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform mat4 pMatrix;\n\n\n//main program for each vertex of the render quad\nvoid main() {\n\n  // My Code\n  float aspectRatio = canvasWidth/canvasHeight;\n  vec3 origin_camSpace, dir_camSpace;\n  if (isOrthographicProjection) {\n    origin_camSpace = vec3(vertex_worldSpace.x*orthographicFOV*aspectRatio,vertex_worldSpace.y*orthographicFOV,0);\n    dir_camSpace = vec3(0, 0, -1);\n  }\n  else { // perspective projection\n    origin_camSpace =  mat3(vMatrix)*vec3(-0.5,0.0,-2.0); //mouse based interaction, makes the scene rotate about location of green sphere\n    dir_camSpace = vec3(vertex_worldSpace.x*aspectRatio,vertex_worldSpace.y,-1.0/tan(radians(perspectiveFOV)));\n  }\n  origin = cameraPosition + cameraRotation*origin_camSpace;\n  dir = normalize(cameraRotation*dir_camSpace);\n  gl_Position =vertex_worldSpace;\n  varyingTextureCoordinate =textureCoordinate_input; \n}"},"fragment":{"source":"precision mediump float;\n\n//a texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n//texture coordinates coming from the vertex shader, interpolated through the rasterizer\nvarying vec2 varyingTextureCoordinate;\nuniform float shininess; //of all objects in scene\nuniform vec3 ambientColor; \nconst int maxdepth=42; //max ray depth\nfloat lightIntensity=1000.0; //light intensity \nfloat kref=0.4; //kref of all objects in scene\nconst float epsilon=0.001; //to prevent self-shadowing\nuniform vec3 lightPosition; //light position in world space\nvarying vec3 origin; //ray origin passed from vertex shader\nvarying vec3 dir; //ray direction passed from vertex shader\nvec3 outputcolor; //final color\n\n//Structs\nstruct Sphere\n{\n  vec3 centre;\n  float radius;\n  vec3 colour;\n}; \n\nstruct Plane\n{\n  vec3 point;\n  vec3 normal;\n  vec3 colour;\n};\n\nstruct Ray\n{\n    vec3 origin; //will bind to variable from vertex shader in 1st ray\n    vec3 dir;//will bind to variable from vertex shader in 1st ray\n};\n\nstruct Intersection\n{\n    vec3 point;\n    vec3 normal; //normal at intersection point \n    vec3 color; //color to return\n    float mu;\n    bool hit; \n    vec3 diffuse; //diffuse lighting at that point \n    vec3 specular; //specular lighting at that point\n};\n\n//Functions\nvoid localIllumination();\nIntersection intersectSphere();\nIntersection intersectPlane();\nbool shadowRay();\nIntersection shadowComputation();\n\n//Function to calculate illumination at intersection point, will only be used if shadow ray doesnt get intercepted\nvoid localIllumination(inout Intersection intersect,Ray ray,vec3 lightPosition,Sphere sphere[6],Plane plane)\n{\n    vec3 normal=intersect.normal;\n    vec3 lightDirection=normalize(lightPosition-intersect.point);\n    vec3 viewingDirection=normalize(ray.origin-intersect.point);\n    vec3 reflectionDirection=normalize(2.0*dot(normal,lightDirection)*normal-lightDirection);\n    float lightDistance=length(lightPosition-intersect.point);\n    float attenuation=1.0/(4.0*3.14*lightDistance*lightDistance);\n    intersect.diffuse = clamp(lightIntensity*attenuation*max(0.0,dot(normal,lightDirection))*intersect.color,0.0,1.0);\n    intersect.specular= clamp(lightIntensity*attenuation*pow(max(0.0,dot(reflectionDirection,viewingDirection)),shininess)*intersect.color,0.0,1.0);\n}\n\n\n//Function to calculate sphere intersections, and return the closest one\nIntersection intersectSphere(Ray ray,Sphere sphere[6],Plane plane) \n{\n    Intersection intersect[6];\n    for (int i=0;i<6;i++)  //testing intercept for each sphere\n    {\n        vec3 deltap=ray.origin-sphere[i].centre;\n        float sqrtterm;\n        sqrtterm=pow(dot(ray.dir,deltap),2.0)-pow(length(deltap),2.0)+pow(sphere[i].radius,2.0);\n        float mu1=-dot(ray.dir,deltap)-sqrt(sqrtterm);\n        float mu2=-dot(ray.dir,deltap)+sqrt(sqrtterm);\n        if (sqrtterm<=0.0 || (mu1<0.0 && mu2<0.0)) //Testing if intersects sphere, and making sure it doesnt \"project\" reflections onto backface\n        {\n            intersect[i].hit=false;\n        }\n        else //if it does intercept\n        {\n            intersect[i].mu=min(mu1,mu2);\n            intersect[i].point=ray.origin+intersect[i].mu*ray.dir;\n            intersect[i].hit=true;\n        }\n    }\n    float minmu;\n    for (int i=0;i<6;i++)\n    {\n        if (intersect[i].hit==true && intersect[i].mu>0.0)\n        {\n            minmu=intersect[i].mu; //initiate minmu\n            break;\n        }\n    }\n    for (int i=0;i<6;i++) //choosing closest intersection\n    {\n        if (intersect[i].hit==true && intersect[i].mu<minmu && intersect[i].mu>0.0)\n        {\n            minmu=intersect[i].mu; //change minmu for the real min\n        }\n    }\n    for (int i=0;i<6;i++) //just for indexing with a non-constant, will return sphere with min mu\n    {\n        if(intersect[i].hit==true && intersect[i].mu==minmu)\n        { \n            //Calculate Local illumination at closest intersect, and return that intersect\n            vec3 normal=normalize(intersect[i].point-sphere[i].centre);\n            intersect[i].normal=normal;\n            intersect[i].color=sphere[i].colour;\n            //local ilumination at the point\n            localIllumination(intersect[i],ray,lightPosition,sphere,plane);\n            return intersect[i]; \n        }\n    }\n    //If it didnt hit any (calculate illumination regardless for smooth interaction when inside a sphere)\n    vec3 normal=normalize(intersect[0].point-sphere[0].centre);\n    intersect[0].normal=normal;\n    intersect[0].color=sphere[0].colour;\n    //local ilumination at the point\n    localIllumination(intersect[0],ray,lightPosition,sphere,plane);\n    return intersect[0]; //didnt hit any, return any cause all will have .hit=false\n}\n\n\n//Plane Intersect Function\nIntersection intersectPlane(Ray ray,Sphere sphere[6],Plane plane)\n{\n    Intersection intersect;\n    float mu1= -dot((ray.origin-plane.point),plane.normal)/dot(ray.dir,plane.normal);\n    if (mu1>=0.0)\n    {\n        intersect.mu=mu1;\n        intersect.point=ray.origin+intersect.mu*ray.dir;\n        intersect.normal=plane.normal;\n        intersect.color=plane.colour;\n        intersect.hit=true;\n\n        //checkerboard\n        float xgrid=floor(intersect.point.x*2.0); \n        float zgrid=floor(intersect.point.z*2.0);\n        if (mod((xgrid+zgrid),2.0)==0.0)\n        {\n            intersect.color=vec3(0,0,0);\n        }\n        //calculating illumination of intersect point\n        localIllumination(intersect,ray,lightPosition,sphere,plane);\n        return intersect;\n    }\n    else //didnt hit plane\n    {\n        intersect.hit=false;\n        return intersect;\n    }\n    \n}\n\n//Shadow Ray Intersection calculation\nbool shadowRay(Intersection intersection,vec3 lightPosition,Sphere sphere[6], Plane plane)\n{\n    Ray new_ray;\n    new_ray.origin=intersection.point+epsilon*intersection.normal;\n    new_ray.dir=normalize(lightPosition-intersection.point);\n    Intersection ifintersectionsphere=intersectSphere(new_ray,sphere,plane);\n    Intersection ifintersectionplane=intersectPlane(new_ray,sphere,plane);\n    if (ifintersectionsphere.hit==true || ifintersectionplane.hit==true)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\n\n//Function that chooses between sphere and plane intersection, based on closest one\nIntersection closestIntersection(Ray ray,Sphere sphere[6],Plane plane)\n{\n    Intersection sphereintersect=intersectSphere(ray,sphere,plane); //closest sphere intersection\n    Intersection planeintersect=intersectPlane(ray,sphere,plane); //closest plane intersection\n    Intersection chosenintersect; //return variable\n    if (sphereintersect.hit==true && planeintersect.hit==true)\n    {\n        if (sphereintersect.mu<planeintersect.mu)\n        {\n            chosenintersect= sphereintersect;\n        }\n        else\n        {\n            chosenintersect= planeintersect;\n        }\n    }\n    else if(sphereintersect.hit==true && planeintersect.hit==false)\n    {\n        chosenintersect= sphereintersect;\n    }\n    else if(sphereintersect.hit==false && planeintersect.hit==true)\n    {\n        chosenintersect= planeintersect;\n    }\n    else\n    {\n        return sphereintersect; //can return either, all will be false\n    }\n    //if it hits something, calculate local illumination and return intersection struct at that point\n    if(shadowRay(chosenintersect,lightPosition,sphere,plane)==false)\n    {\n        chosenintersect.color=ambientColor+chosenintersect.specular+chosenintersect.color*(chosenintersect.diffuse); //stylistic choice to multiply diffuse by color\n        return chosenintersect;\n    }\n    else //shadow ray gets blocked, only return ambient component\n    {\n        chosenintersect.color=ambientColor;\n        return chosenintersect;\n    }\n}\n\n//Built this function but didn't use it because it does the same as the reflect in-built function\nvec3 reflectdirection(vec3 direction,vec3 normal) \n{\n    vec3 reflectiondir;\n    reflectiondir=direction-(2.0*dot(normalize(direction),normalize(normal)))*normalize(normal);\n    return normalize(reflectiondir);\n}\n\n\n//main program for each fragment of the render quad\nvoid main() {\n\n    //Scene Definition Beginning\n    Sphere sphere[6]; //array of structs\n    Plane plane;\n    sphere[0].centre=vec3(-2.0,1.5,-3.5);\n    sphere[0].radius=1.5;\n    sphere[0].colour=vec3(0.8,0.8,0.8);\n    sphere[1].centre=vec3(-0.5,0.0,-2.0);\n    sphere[1].radius=0.6;\n    sphere[1].colour=vec3(0.3,0.8,0.3);\n    sphere[2].centre=vec3(1.0,0.7,-2.2);\n    sphere[2].radius = 0.8;\n    sphere[2].colour = vec3(0.3,0.8,0.8);\n    sphere[3].centre = vec3(0.7, -0.3, -1.2);\n    sphere[3].radius = 0.2;\n    sphere[3].colour = vec3(0.8,0.8,0.3);\n    sphere[4].centre = vec3(-0.7, -0.3, -1.2);\n    sphere[4].radius = 0.2;\n    sphere[4].colour = vec3(0.8,0.3,0.3);\n    sphere[5].centre = vec3(0.2, -0.2, -1.2);\n    sphere[5].radius = 0.3;\n    sphere[5].colour = vec3(0.8,0.3,0.8);\n    plane.point = vec3(0,-0.5, 0);\n    plane.normal = vec3(0, 1.0, 0);\n    plane.colour = vec3(1, 1, 1);\n    //scene definition end\n\n    //LOOPING\n    vec3 outputcolor;\n    Ray curr_ray;\n    Intersection intersection;//initializing intersection point\n    intersection.hit=false; //initializing intersection point\n    intersection.color=vec3(0.0,0.0,0.0);//initializing intersection point\n    curr_ray.origin=origin; //initializing 1st ray with variables from vertex shader\n    curr_ray.dir=normalize(dir); //initializing 1st ray with variables from vertex shader\n    for(int currdepth=0;currdepth<maxdepth;currdepth+=1)\n    {\n        intersection=closestIntersection(curr_ray,sphere,plane); //returns 1st intersection(in terms of distance) of ray\n        if(intersection.hit!=false)\n        {\n            outputcolor+=intersection.color*pow(kref,float(currdepth));\n        }\n        else\n        {\n            break; //ray didnt intersect anything\n        }\n        curr_ray.origin=intersection.point+epsilon*intersection.normal; //change curr ray to start at the intersection point in next iteration\n        curr_ray.dir=normalize(reflect(curr_ray.dir,normalize(intersection.normal))); //in built reflect function\n    }\n\n  gl_FragColor = vec4(outputcolor,1.0);\n}"}},"uniforms":{"value":{"canvasWidth":{"value":[900]},"canvasHeight":{"value":[500]},"cameraPosition":{"attachment":"Camera Position"},"cameraRotation":{"attachment":"Camera Rotation"},"isOrthographicProjection":{"value":[false]},"orthographicFOV":{"value":[0]},"perspectiveFOV":{"value":[45]},"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"},"textureRendered":{"value":{"TEXTURE_2D":""}},"shininess":{"value":[10]},"ambientColor":{"value":[0.05,0.05,0.05]},"lightPosition":{"value":[6,4,3]}}}}}},"output":{"image":"Quad/R2T Pass color"}}